Rust was designed to deliver the high performance typically associated with C and C++, while also prioritizing memory safety. However, there's much more to Rust's appeal beyond just these:


1. Efficient handling of large data processing
2. Robust support for concurrent programming
3. A powerful and effective compiler

Why is RUST growing so much in popularity?
Rust is a statically-typed programming language designed for performance and safety, with a particular emphasis on safe concurrency and memory management. Its syntax is reminiscent of C++, and it is an open-source project initially developed by Mozilla Research.
One of Rust's standout qualities is its ability to address many of the issues faced by C and C++. While C++ has made significant strides in improving memory safety, many errors still persist. For example, "use after free" errors occur when a program continues to use a pointer after it has been freed, such as calling a lambda function after freeing its reference-captured objects.
The Borrow Checker:
-----------------
The borrow checker is Rust's "secret sauce." It enforces several important properties: all variables must be initialized before use, a value cannot be moved twice, and a value cannot be moved while it is borrowed. The borrow checker is part of the Rust compiler and ensures that references are always valid. This eliminates ambiguity in the code and prevents references to invalid memory locations.


Online Editor:
--------------
https://play.rust-lang.org/



Comments:
==========

format :
Block comments:
/* 

*/
Single line comments:
//

snippet:
/* This is comment */

/*
This is also comment
*/

// This is a single line comments

/// Document comments are parsed into HTML  library documentation

fn main() {
    println!("Hello, world!");
}


Hello World example in Rust:
================================
/* 
This first program in rust
*/

fn main()
{
	// is the logic for the code
	// ! refers macros functions. This is not actual function
	println! ("Hello world! Welcome to rust world");
}

Datatypes in Rust:
====================
Datatypes - Specifies what type of value a variable has.

The compiler automatically infers the data type of a variable based on the value assigned to it

How to declare variables in Rust?  : use the let keyword to declare variables in rust.

/* 
This first program in rust
*/

fn main()
{
    let str_var = "String Variable";
    let int_var = 240; //(whole numbers)
    let bool_var = true;
    let float_var = 240.00;
    
    println! ("My str variable - {} and int variable - {} float variable - {}", str_var, int_var, float_var);
}

Macros:
==============
In Rust, macros are a way to extend the language itself. They allow you to define a set of rules for generating code at compile-time, which can then be used to create new functionality or abstractions.

Macros in Rust are similar to macros in other languages, such as C or Lisp. However, Rust's macro system is more powerful and flexible, thanks to its focus on safety and hygiene.

/* 
This program demonstrates macros in rust
*/

fn main()
{
    // In general, {} will be automatically replaced with any arguments
    // and stringified
    
    println!("{} years old", 36);
    
    //named arguments also work
    
    println!("{user1} {action} {user2}",
                user1 = "Mary Lewis",
                user2 = "Jon wick",
                action= "Karate kicked");
}

different macros:
format!: write formmated text to string
print! : io::stdout
println!

eprint!: io::stderr
eprintln!

Integers in Rust:
====================
Integers represents whole numbers.
Integers are signed and unsigned.
The size of an intger can be set to arch

/*
	This code demonstrates Integers demonstration
*/
fn main()
{
	let total = 4; //default i32
	let height:u32 = 41;
	let deduction:i32 = 2-200;
	
	println!("The total is {}", total);
	println!("The height is {} and deduction is {}", height, deduction);
}


Integers Range and overflow in Rust:
---------------------------------------
Signed integers can store from -2^(n-1)  to 2^(n-1) - 1  ; n is the number of bits

unsigned integers can range from 0 to 2^(n-1)-1



Variables in Rust:
==========================
Variable naming convention is same as C

datatype declaration is automatic.
Variables are immutable by default means they are readonly by default.

we can apply mut keyword to make them mutable.

/*
	This code demonstrates variables
*/
fn main()
{
	let x = 5;
	x = x+1;
	
	println!("{}", x); //Error:  assign twice to immutable variable
}

/*
	This code demonstrates variables
*/
fn main()
{
	let mut x = 5;
	x = x+1;
	
	println!("{}", x);  // Output is 6
}



Constants in Rust:
===================
All the characters in constant varibale should be in upper case for proper convention

/*
	This code demonstrates constants
*/
fn main()
{
	let x = 5;
    let x = 6;
	println!("{}", x);  // print 6
	
	const Y:i32 = 5;
	const Y = 6;
	
	println!("{}", y);  // Error: the name `Y` is defined multiple times
	
	const y:i32 = 5;

	println!("{}", y);  //warning: constant `y` should have an upper case name

}


Strings in Rust:
=====================
Strings: Set of characters hard coded into a variable

/*
	This code demonstrates strings
*/
fn main()
{
    let bank:&str = "Citi bank";
    let currency:&str = "Bit coin";
    
    println!("Bank is {} and currency is {}", bank, currency);
    
    
    /*
    In general, when you want to create a string slice that can be used throughout the program,
    you should use &'static str. When you want to create a string slice that is only valid 
    within a specific scope, you can use &str.
    */
    // Explicitly declare static strings
    let bank2:&'static str = "Citi bank";
    let currency2:&'static str = "Bit coin";
    
    println!("Bank is {} and currency is {}", bank2, currency2);
    
}

String Literal  (&str)
String Object  (String)

String literals are static by default. This ensures that string is valid 
for the entire duration of the program. you can explicitly declare string as static.

String Object:
----------------
fn main()
{
    let nothing_in = String::new();
    println!("{}", nothing_in.len());
    
    let great_movie = String::from("Bahubali");
    println!("{}", great_movie.len());

}


String Object Methods:
------------------------
new()
len()
push()
push_str()
to_string()
replace()
as_str()
trim()
split_whitespace()
split()
chars()


fn main()
{
    let nothing_in = String::new();
    println!("{}", nothing_in.len()); //0
    
    let great_movie = String::from("Bahubali");
    println!("{}", great_movie.len()); //8
    
    // Push Example
    let mut greeting = String::from("I said ");
    greeting.push_str("hello");
    
    println!("{}",greeting);  // I said hello
    
    //convert string lieteral to string object
    
    let random_string = "Please make me to an object".to_string();
    println!("{}", random_string); //Please make me to an object
    
    
}


Operators in Rust:
====================
Major operators in rust are

Arithmetic:
-------------
+ 
-
* 
/ - Quotient
% - Remainder

Bitwise:
------------

Relational: (returns boolean)
------------
>
<
>=
<=
==
!=

logical: (returns boolean)
----------
&&
||
!

Decision Making:
=====================
if (statement)



if(statement)
.
.
else


if(statement)
.
.
else if(statement)
.
.
else


fn main()
{
    let user = "todd";
    
    if user.len() == 4 {
        println!("No characters are 4")
    }
    
    if user.len() == 4 {
        println!("No characters are 4")
    } else if user.len() == 3 {
        println!("No characters are 3")
    } else {
        println!("No characters are neither 3 nor 4")
    }
    
}


Match Statement(Switch equivalent in c):
-----------------------------------------

/*
	This code demonstrates Match statment
*/
fn main()
{
    let microbiome = "xc12";
    let bodypart = match microbiome {
        "xc12" => {println!("Found match for microbiome"); "Tummy Biome" },
        "mpt1" => "Eyebiome",
        "ttw6" => "Finger biome",
        _ => "Unknown"
    };
    
    println!("The biome match is {}", bodypart); 
    
}

O/p: Found match for microbiome
The biome match is Tummy Biome


Loops in Rust:
=================
Rust has three types of core loops
1. while
2. loop
3. for

/*
	This code demonstrates loops
*/
fn main()
{
    // For loop
    for a in 1..20 { // 20 is not included
        if a == 2 {
            continue; // Demonstrates continue statement
        }
        print!("{} ",a);
        if a == 13 {
            break;
        }
    }
    
    println!("");
    
    // While loop
    let mut i = 0;
    while i < 5 {
        print!("{} ",i);
        i+=1;
    }
    println!("");
    
    //loop statment
    let mut j = 0;
    loop {
        j -= 1;
        print!("j={} ", j);
        
        if j == -10 {
            break;
        }
    }
    
}

o/p:
1 3 4 5 6 7 8 9 10 11 12 13 
0 1 2 3 4 
j=-1 j=-2 j=-3 j=-4 j=-5 j=-6 j=-7 j=-8 j=-9 j=-10 


Functions in Rust:
====================
/*
	This code demonstrates functions
*/

fn fn_function() {
    println!("Hello, I am a function"); //Hello, I am a function
}

//function with return values
fn fn_return() -> bool {
    return true;
}

//parameterized functions
fn fn_param(x:i32) {
    println!("The value of x is {}", x);
}

fn main()
{
    println!("I am in main function"); //I am in main function
    fn_function();
    println!("returned {}", fn_return()); //returned true
    fn_param(28);
    
}

o/p:

I am in main function
Hello, I am a function
returned true
The value of x is 28



Tuples in Rust:
=================
Tuples are compound data types, can store multiple data elements of different types. Tuples have fixed lengths, Once declared, they cant grow or shrink in size

/*
	This code demonstrates tuples
*/

fn main()
{
    let tuple:(i8, f32, i32) = (2, 3.4, 100);
    println!("{:?}", tuple);
    println!("first value {:?}", tuple.0 );
    
}

/*
	This code demonstrates tuples
*/

fn main()
{
    let user2:(i32, bool, &str) = (30,true, "jack");
    user_data(user2);
}

fn user_data(x:(i32, bool, &str))
{
    let (age, active, name) = x;
    println!("age : {}, active:{}, name:{}", age, active, name);
}

Arrays in Rust:
===================
Array is a collection of objects of same type T and stored in contiguos memory
Arrays are static , can't be resized once initialized.

/*
	This code demonstrates Arrays
*/

fn main()
{
    //let arr:[&str;4] = ["Hello", "Hi", "see", "you"]; //Method 1
    
    let mut arr = ["Hello", "Hi", "see", "you"]; //Method 2
    println!("Arrays contains {:?}", arr);
    println!("Array total len = {}", arr.len());
    arr[1] = "test";
    println!("Arrays contains {:?}", arr);
    
    //iter function
    for value in arr.iter() {
        println!("{}", value);
    }
}

fn user_data(x:(i32, bool, &str))
{
    let (age, active, name) = x;
    println!("age : {}, active:{}, name:{}", age, active, name);
}

/*
	This code demonstrates Arrays
*/

fn main()
{
    let mut arr = [12, 2, 3, 2, 4, 5];
    
    for i in 0..arr.len() {
        if arr[i] == 2 {
            arr[i] = 0;
        }
        println!("index is : {} and values is {}",i, arr[i]);
    }
    
    println!("New array {:?}", arr);
}


Stack Vs Heap in the Rust:
===========================

Ownership in Rust:
==================
All the data that is stores in rust has an owner associated to it.

let time = 20 - time is the owner of the value 20

data has only one owner at a time.
Multiple variable can't point to same memory location at a time.
Varibles always point to different memory locations.

you can transfer the ownership in rust.

/*
	This code demonstrates ownership
*/

fn main()
{
    let vector1 = vec![2,4,6];
    //vector vector1 owns the object in the heap
    //only single variable owns the heap memory at a given time
    
    let vector2 = vector1;
    
    println!("{:?}", vector2); //[2, 4, 6]
    //println!("{:?}", vector1); //error[E0382]: borrow of moved value: `vector1`
}

Borrowing in Rust - & symbol in rust:
========================================
/*
	This code demonstrates ownership
*/

fn main()
{
    let vector = vec![2,4,6];
    
    //display(vector);
    
    //println!("{}", vector[1]); //error[E0382]: borrow of moved value: `vector`
    
    display(&vector);
    println!("{}", vector[1]); 
}

//fn display(x:Vec<i32>) { //Error case
fn display(x:&Vec<i32>) {
    println!("{:?}", x);
}

/*
	This code demonstrates ownership
*/

fn main()
{
    let mut car:String = String::from("Ferrari");
    
    display2(&mut car);
    
    println!("car now is {}", car);
   
}

fn display2(car:&mut String)
{
    println!("car value {}", car);
    car.push_str("F8 Tributo");
}


Slicing in Rust:
===================
/*
	This code demonstrates slices
*/

fn main()
{
    let game = "Mario Brothers".to_string();
    println!("len of the game is {}", game.len()); //len of the game is 14
    
    let slice = &game[0..5]; 
    println!("{}", slice); //Mario. 5 is not included
   
}

/*
	This code demonstrates slices
*/

fn main()
{
    let mut nums = [1, 2, 3, 4, 5];
    
    println!("{:?}", nums);
    slice_and_dice(&mut nums[1..3]);
    println!("{:?}", nums);
   
}

fn slice_and_dice(slice:&mut [i32])
{
    println!("Length of slice is {}", slice.len());
    println!("{:?}", slice);
    slice[0] = 200;
}


Structs in Rust:
===================
unlike tuples, in structs we can name each piece of data.

/*
	This code demonstrates structs
*/

struct House {
    door:String,
    garden:String,
    property:u32
}

fn main()
{
    let home1 = House {
        door:String::from("Blue"),
        garden:String::from("Beatiful"),
        property:100000
    };
    
    println!("door is {}, garden is {}, property is {}", home1.door, home1.garden, home1.property);
   
}


Methods are functions which belongs in the scope within a structure.
We can use impl keyword to declare methods outside of structure block

/*
	This code demonstrates methods in structs
*/

struct Triangle {
    base:u32,
    height:u32,
}

impl Triangle{
    fn find_area(&self) -> u32 {
        return (self.base * self.height) / 2; 
    }
}

fn main()
{
    let new_traingle = Triangle {
        base:10,
        height:30
    };
    
    println!("Area of tringle is {}", new_traingle.find_area());
}
    
Enums in Rust:
================
Enums are set of predefined constans

/*
	This code demonstrates Enums
*/

//The derive attribute makes the enum printable
#[derive(Debug)]
enum TemperatureGrade {
    Hot, Cold, Medium
}

#[derive(Debug)]
struct City {
    name:String,
    temperature:TemperatureGrade
}

fn main()
{
    let c1 = City {
        name:String::from("Bangalore"),
        temperature:TemperatureGrade::Cold
    };
    
    let c2 = City {
        name:String::from("Tirupathi"),
        temperature:TemperatureGrade::Hot
    };
    
    println!("{:?}", c1);
    
    println!("{:?}", c2);
}

City { name: "Bangalore", temperature: Cold }
City { name: "Tirupathi", temperature: Hot }

Exercise:
---------
/*
	This code demonstrates Enums
*/

//The derive attribute makes the enum printable
#[derive(Debug)]
enum Shoes {
    Loafer,
    Nike,
    Vans
}

fn print_shoes(shoe:Shoes) {
    match shoe {
        Shoes::Nike => {
            println!("Great for running");
        },
        Shoes::Loafer => {
            println!("Great for loafing around");
        },
        Shoes::Vans => {
            println!("Great for skate boarding");
        }
    }
    
}

fn main()
{
    print_shoes(Shoes::Nike);
    print_shoes(Shoes::Loafer);
    print_shoes(Shoes::Vans);
}

Modules in Rust:
=================
modules helps to split the code into logical units.
A module is a collection of items:
functions, structs, traits, impl blocks, and even other modules

multiple modules are compiled into a unit called crate.

Cargo tool is used to manage crates in Rust.

use keyword helps to import a public module

/*
	This code demonstrates modules
*/

pub mod songs {
    pub fn play(name:String) {
        println!("track selection {}", name);
    }
}

use songs::play;

fn main()
{
    play("Kissed by a Rose".to_string());
}

Nested modules in Rust:
------------------------
/*
	This code demonstrates Nested modules
*/

pub mod tracks {
    pub mod rock {
        pub mod indie {
            pub fn select(name:String) {
                println!("Track selection is {}", name);
            }
        }
    }
}

use tracks::rock::indie::select;

fn main()
{
    select("Serenade".to_string());
    select("loyola".to_string());
    select("love me like you do".to_string());
}


Hashmaps in Rust:
==================
Rust's standard collection library has implementation of some of the most common data structure for general purpose

/*
	This code demonstrates Hashmaps
*/

use std::collections::HashMap;

fn main()
{
    let mut accountInfo = HashMap::new();
    accountInfo.insert("Jony", "Overdraft");
    accountInfo.insert("Sally", "Good standing");
    accountInfo.insert("Super man", "Insufficient funds");
    
    println!("The size of the maps is {}", accountInfo.len());  //3
    
}

/*
	This code demonstrates Hashmaps
*/


use std::collections::HashMap;

fn main()
{
    let mut bar_drinks = HashMap::new();
    
    bar_drinks.insert("vodka", true);
    bar_drinks.insert("beer", false);
    bar_drinks.insert("Whiskey", true);
    
    println!("{:?}", bar_drinks);
    
    bar_drinks.remove(&"Whiskey");
    
    println!("{:?}", bar_drinks);
}

{"Whiskey": true, "vodka": true, "beer": false}
{"vodka": true, "beer": false}
