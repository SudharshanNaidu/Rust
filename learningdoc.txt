Rust was designed to deliver the high performance typically associated with C and C++, while also prioritizing memory safety. However, there's much more to Rust's appeal beyond just these:


1. Efficient handling of large data processing
2. Robust support for concurrent programming
3. A powerful and effective compiler

Why is RUST growing so much in popularity?
Rust is a statically-typed programming language designed for performance and safety, with a particular emphasis on safe concurrency and memory management. Its syntax is reminiscent of C++, and it is an open-source project initially developed by Mozilla Research.
One of Rust's standout qualities is its ability to address many of the issues faced by C and C++. While C++ has made significant strides in improving memory safety, many errors still persist. For example, "use after free" errors occur when a program continues to use a pointer after it has been freed, such as calling a lambda function after freeing its reference-captured objects.
The Borrow Checker:
-----------------
The borrow checker is Rust's "secret sauce." It enforces several important properties: all variables must be initialized before use, a value cannot be moved twice, and a value cannot be moved while it is borrowed. The borrow checker is part of the Rust compiler and ensures that references are always valid. This eliminates ambiguity in the code and prevents references to invalid memory locations.


Online Editor:
--------------
https://play.rust-lang.org/



Comments:
==========

format :
Block comments:
/* 

*/
Single line comments:
//

snippet:
/* This is comment */

/*
This is also comment
*/

// This is a single line comments

/// Document comments are parsed into HTML  library documentation

fn main() {
    println!("Hello, world!");
}


Hello World example in Rust:
================================
/* 
This first program in rust
*/

fn main()
{
	// is the logic for the code
	// ! refers macros functions. This is not actual function
	println! ("Hello world! Welcome to rust world");
}

Datatypes in Rust:
====================
Datatypes - Specifies what type of value a variable has.

The compiler automatically infers the data type of a variable based on the value assigned to it

How to declare variables in Rust?  : use the let keyword to declare variables in rust.

/* 
This first program in rust
*/

fn main()
{
    let str_var = "String Variable";
    let int_var = 240; //(whole numbers)
    let bool_var = true;
    let float_var = 240.00;
    
    println! ("My str variable - {} and int variable - {} float variable - {}", str_var, int_var, float_var);
}

Macros:
==============
In Rust, macros are a way to extend the language itself. They allow you to define a set of rules for generating code at compile-time, which can then be used to create new functionality or abstractions.

Macros in Rust are similar to macros in other languages, such as C or Lisp. However, Rust's macro system is more powerful and flexible, thanks to its focus on safety and hygiene.

/* 
This program demonstrates macros in rust
*/

fn main()
{
    // In general, {} will be automatically replaced with any arguments
    // and stringified
    
    println!("{} years old", 36);
    
    //named arguments also work
    
    println!("{user1} {action} {user2}",
                user1 = "Mary Lewis",
                user2 = "Jon wick",
                action= "Karate kicked");
}

different macros:
format!: write formmated text to string
print! : io::stdout
println!

eprint!: io::stderr
eprintln!

Integers in Rust:
====================
Integers represents whole numbers.
Integers are signed and unsigned.
The size of an intger can be set to arch

/*
	This code demonstrates Integers demonstration
*/
fn main()
{
	let total = 4; //default i32
	let height:u32 = 41;
	let deduction:i32 = 2-200;
	
	println!("The total is {}", total);
	println!("The height is {} and deduction is {}", height, deduction);
}


Integers Range and overflow in Rust:
---------------------------------------
Signed integers can store from -2^(n-1)  to 2^(n-1) - 1  ; n is the number of bits

unsigned integers can range from 0 to 2^(n-1)-1



Variables in Rust:
==========================
Variable naming convention is same as C

datatype declaration is automatic.
Variables are immutable by default means they are readonly by default.

we can apply mut keyword to make them mutable.

/*
	This code demonstrates variables
*/
fn main()
{
	let x = 5;
	x = x+1;
	
	println!("{}", x); //Error:  assign twice to immutable variable
}

/*
	This code demonstrates variables
*/
fn main()
{
	let mut x = 5;
	x = x+1;
	
	println!("{}", x);  // Output is 6
}



Constants in Rust:
===================
All the characters in constant varibale should be in upper case for proper convention

/*
	This code demonstrates constants
*/
fn main()
{
	let x = 5;
    let x = 6;
	println!("{}", x);  // print 6
	
	const Y:i32 = 5;
	const Y = 6;
	
	println!("{}", y);  // Error: the name `Y` is defined multiple times
	
	const y:i32 = 5;

	println!("{}", y);  //warning: constant `y` should have an upper case name

}


Strings in Rust:
=====================
Strings: Set of characters hard coded into a variable

/*
	This code demonstrates strings
*/
fn main()
{
    let bank:&str = "Citi bank";
    let currency:&str = "Bit coin";
    
    println!("Bank is {} and currency is {}", bank, currency);
    
    
    /*
    In general, when you want to create a string slice that can be used throughout the program,
    you should use &'static str. When you want to create a string slice that is only valid 
    within a specific scope, you can use &str.
    */
    // Explicitly declare static strings
    let bank2:&'static str = "Citi bank";
    let currency2:&'static str = "Bit coin";
    
    println!("Bank is {} and currency is {}", bank2, currency2);
    
}

String Literal  (&str)
String Object  (String)

String literals are static by default. This ensures that string is valid 
for the entire duration of the program. you can explicitly declare string as static.

String Object:
----------------
fn main()
{
    let nothing_in = String::new();
    println!("{}", nothing_in.len());
    
    let great_movie = String::from("Bahubali");
    println!("{}", great_movie.len());

}


String Object Methods:
------------------------
new()
len()
push()
push_str()
to_string()
replace()
as_str()
trim()
split_whitespace()
split()
chars()


fn main()
{
    let nothing_in = String::new();
    println!("{}", nothing_in.len()); //0
    
    let great_movie = String::from("Bahubali");
    println!("{}", great_movie.len()); //8
    
    // Push Example
    let mut greeting = String::from("I said ");
    greeting.push_str("hello");
    
    println!("{}",greeting);  // I said hello
    
    //convert string lieteral to string object
    
    let random_string = "Please make me to an object".to_string();
    println!("{}", random_string); //Please make me to an object
    
    
}


Operators in Rust:
====================
Major operators in rust are

Arithmetic:
-------------
+ 
-
* 
/ - Quotient
% - Remainder

Bitwise:
------------

Relational: (returns boolean)
------------
>
<
>=
<=
==
!=

logical: (returns boolean)
----------
&&
||
!

Decision Making:
=====================
if (statement)



if(statement)
.
.
else


if(statement)
.
.
else if(statement)
.
.
else


fn main()
{
    let user = "todd";
    
    if user.len() == 4 {
        println!("No characters are 4")
    }
    
    if user.len() == 4 {
        println!("No characters are 4")
    } else if user.len() == 3 {
        println!("No characters are 3")
    } else {
        println!("No characters are neither 3 nor 4")
    }
    
}


Match Statement(Switch equivalent in c):
-----------------------------------------

/*
	This code demonstrates Match statment
*/
fn main()
{
    let microbiome = "xc12";
    let bodypart = match microbiome {
        "xc12" => {println!("Found match for microbiome"); "Tummy Biome" },
        "mpt1" => "Eyebiome",
        "ttw6" => "Finger biome",
        _ => "Unknown"
    };
    
    println!("The biome match is {}", bodypart); 
    
}

O/p: Found match for microbiome
The biome match is Tummy Biome


Loops in Rust:
=================
Rust has three types of core loops
1. while
2. loop
3. for

/*
	This code demonstrates loops
*/
fn main()
{
    // For loop
    for a in 1..20 { // 20 is not included
        if a == 2 {
            continue; // Demonstrates continue statement
        }
        print!("{} ",a);
        if a == 13 {
            break;
        }
    }
    
    println!("");
    
    // While loop
    let mut i = 0;
    while i < 5 {
        print!("{} ",i);
        i+=1;
    }
    println!("");
    
    //loop statment
    let mut j = 0;
    loop {
        j -= 1;
        print!("j={} ", j);
        
        if j == -10 {
            break;
        }
    }
    
}

o/p:
1 3 4 5 6 7 8 9 10 11 12 13 
0 1 2 3 4 
j=-1 j=-2 j=-3 j=-4 j=-5 j=-6 j=-7 j=-8 j=-9 j=-10 


Functions in Rust:
====================
/*
	This code demonstrates functions
*/

fn fn_function() {
    println!("Hello, I am a function"); //Hello, I am a function
}

//function with return values
fn fn_return() -> bool {
    return true;
}

//parameterized functions
fn fn_param(x:i32) {
    println!("The value of x is {}", x);
}

fn main()
{
    println!("I am in main function"); //I am in main function
    fn_function();
    println!("returned {}", fn_return()); //returned true
    fn_param(28);
    
}

o/p:

I am in main function
Hello, I am a function
returned true
The value of x is 28
